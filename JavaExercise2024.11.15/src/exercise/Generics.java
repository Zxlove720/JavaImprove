package exercise;

public class Generics {
    // 泛型：泛型是JDK5之后引入的新特性，提供了编译时类型安全检测机制

    // 在泛型引入之前：
    // 类似List集合这种存储数据的类可以传递任何数据类型,因为其中需要的类是Object
    /* List.add(1)
       List.add("String")
       List.add("Student") */
    // 看似是好处，不必在意集合中到底需要什么内容，什么内容都可以添加

    // 泛型引入之前的问题！
    /*
    集合中什么类型的元素都可以添加，添加确实十分方便；
    但使用起来就十分不方便，因为其中的类全部是Object；所以说从集合中取出的都是Object类的元素；但正因为Object是顶级父类，
    父类无法使用子类中特有的方法，所以说想要使用这些子类中的特有方法，需要向下转型。

    但是由于集合中什么元素都存在，完全不知道什么类型是什么类型，所以说无法正确的向下转型，运行时就会遇到问题，抛出异常（转型异常）
    */

    // 泛型在JDK之后引入之后，就限定了该集合中只能存在元素类型，如ArrayList<String>，那么这个ArrayList就只能添加String类型的元素
    // 假如在ArrayList<String>中添加了非String的元素，那么就会直接编译时报错，就可以把运行时遇见的问题提前到了编译时

    // 泛型擦除：
    // 泛型在集合中的实际情况
    /* 在 Java 中，泛型信息主要是在编译阶段起作用，当代码编译成字节码后，泛型相关的类型信息会被擦除。如ArrayList<String>，在编译时
    会检查添加到集合内的元素是否是String，若不是则报错；但是在编译为字节码文件之后，泛型信息就会被擦除，集合中的元素被“擦除”为Object类型，
    但是因为限定了泛型，所以说在获取元素的时候，会按照泛型对Object类进行转型，不会发生错误 */

}
